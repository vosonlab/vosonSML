#' @title Add columns containing text data to network dataframes
#'
#' @description Network is supplemented with additional social media text data applied as node or edge attributes.
#'
#' @note Supports social media \code{activity} and \code{actor} networks. Refer to \code{\link{AddText.activity.reddit}} and
#' \code{\link{AddText.actor.reddit}} for additional reddit parameters. Refer to \code{\link{AddText.actor.youtube}}
#' for additional YouTube actor network parameters.
#'
#' @param net A named list of dataframes \code{nodes} and \code{edges} generated by \code{Create}.
#' @param data A dataframe generated by \code{Collect}.
#' @param verbose Logical. Output additional information. Default is \code{FALSE}.
#' @param ... Additional parameters passed to function.
#'
#' @return Network as a named list of two dataframes containing \code{$nodes} and \code{$edges}
#' including columns containing text data.
#'
#' @examples
#' \dontrun{
#' # add text to an activity network
#' activityNetwork <- collectData |> Create("activity") |> AddText(collectData)
#'
#' # network
#' # activityNetwork$nodes
#' # activityNetwork$edges
#' }
#'
#' @aliases AddText
#' @name AddText
#' @export
AddText <- function(net, data, verbose = FALSE, ...) {
  msg <- f_verbose(verbose)
  msg("Adding text to network...")

  # searches the class list of net for matching method
  UseMethod("AddText", net)
}

#' @noRd
#' @export
AddText.default <- function(net, ...) {
  stop("Unknown network type passed to AddText.", call. = FALSE)
}

#' @noRd
#' @method AddText activity
#' @export
AddText.activity <- function(net, ...) {
  UseMethod("AddText.activity", net)
}

#' @noRd
#' @export
AddText.activity.default <- function(net, ...) {
  stop("Unknown social media type passed to AddText.", call. = FALSE)
}

#' @title Add columns containing text data to twitter activity network dataframes
#'
#' @param net A named list of dataframes \code{nodes} and \code{edges} generated by \code{Create}.
#' @param data A dataframe generated by \code{Collect}.
#' @param hashtags Logical. Add tweet hashtags to dataframes. Default is \code{FALSE}.
#' @param ... Additional parameters passed to function. Not used in this method.
#'
#' @return Network as a named list of two dataframes containing \code{$nodes} and \code{$edges}
#' including columns containing text data.
#'
#' @aliases AddText.activity.twitter
#' @name AddText.activity.twitter
#' @export
AddText.activity.twitter <- function(net, data, hashtags = FALSE, ...) {
  class(data) <- rm_collect_cls(class(data))

  net$nodes <- add_tweet_text(net$nodes, data, hashtags)

  class(net) <- union(class(net), c("vosontxt"))
  msg("Done.\n")

  net
}

#' @noRd
#' @export
AddText.activity.youtube <- function(net, data, ...) {
  # data <- tibble::as_tibble(data)
  class(data) <- rm_collect_cls(class(data))

  net$nodes <- dplyr::left_join(
    net$nodes,
    dplyr::select(data, .data$CommentID, .data$Comment) |>
      dplyr::rename(
        id = .data$CommentID,
        vosonTxt_comment = .data$Comment
      ),
    by = c("id")
  )

  class(net) <- union(class(net), c("vosontxt"))
  msg("Done.\n")

  net
}

#' @title Add columns containing text data to reddit activity network dataframes
#'
#' @param net A named list of dataframes \code{nodes} and \code{edges} generated by \code{Create}.
#' @param data A dataframe generated by \code{Collect}.
#' @param cleanText Logical. Simple removal of problematic characters for XML 1.0 standard. Implemented to prevent
#' reddit specific XML control character errors when generating graphml files. Default is \code{FALSE}.
#' @param ... Additional parameters passed to function. Not used in this method.
#'
#' @return Network as a named list of two dataframes containing \code{$nodes} and \code{$edges}
#' including columns containing text data.
#'
#' @aliases AddText.activity.reddit
#' @name AddText.activity.reddit
#' @export
AddText.activity.reddit <-
  function(net, data, cleanText = FALSE, ...) {
    # data <- tibble::as_tibble(data)
    class(data) <- rm_collect_cls(class(data))

    net$nodes <- dplyr::left_join(
      net$nodes,
      dplyr::mutate(data, id = paste0(.data$thread_id, ".", .data$structure)) |>
        dplyr::select(.data$id, .data$subreddit, .data$comment),
      by = c("id", "subreddit")
    )

    threads <-
      dplyr::select(data,
                    .data$subreddit,
                    .data$thread_id,
                    .data$title,
                    .data$post_text) |>
      dplyr::distinct() |> dplyr::mutate(id = paste0(.data$thread_id, ".0"), thread_id = NULL)

    net$nodes <-
      dplyr::left_join(net$nodes, threads, by = c("id", "subreddit")) |>
      dplyr::mutate(comment = ifelse(.data$node_type == "thread", .data$post_text, .data$comment)) |>
      dplyr::select(-c(.data$post_text)) |> dplyr::rename(vosonTxt_comment = .data$comment)

    if (cleanText) {
      net$nodes$vosonTxt_comment <-
        xml_clean_reddit(net$nodes$vosonTxt_comment)
      net$nodes$title <- xml_clean_reddit(net$nodes$title)
    }

    class(net) <- union(class(net), c("vosontxt"))
    msg("Done.\n")

    net
  }

#' @noRd
#' @method AddText actor
#' @export
AddText.actor <- function(net, ...) {
  UseMethod("AddText.actor", net)
}

#' @noRd
#' @export
AddText.actor.default <- function(net, ...) {
  stop("Unknown social media type passed to AddText.", call. = FALSE)
}

#' @title Add columns containing text data to twitter actor network dataframes
#'
#' @param net A named list of dataframes \code{nodes} and \code{edges} generated by \code{Create}.
#' @param data A dataframe generated by \code{Collect}.
#' @param hashtags Logical. Add tweet hashtags to dataframes. Default is \code{FALSE}.
#' @param ... Additional parameters passed to function. Not used in this method.
#'
#' @return Network as a named list of two dataframes containing \code{$nodes} and \code{$edges}
#' including columns containing text data.
#'
#' @aliases AddText.actor.twitter
#' @name AddText.actor.twitter
#' @export
AddText.actor.twitter <- function(net, data, hashtags = FALSE, ...) {
  class(data) <- rm_collect_cls(class(data))

  net$edges <- add_tweet_text(net$edges, data, hashtags)

  class(net) <- union(class(net), c("vosontxt"))
  msg("Done.\n")

  net
}

#' @title Add columns containing text data to YouTube actor network dataframes
#'
#' @description Text comments are added to the network as edge attributes. References to actors
#' are detected at the beginning of comments and edges redirected to that actor instead if they
#' differ from the top-level comment author.
#'
#' @param net A named list of dataframes \code{nodes} and \code{edges} generated by \code{Create}.
#' @param data A dataframe generated by \code{Collect}.
#' @param repliesFromText Logical. If comment text for an edge begins with \code{screen_name} change the
#' edge to be directed to \code{screen_name} - if different from the top level comment author that the reply
#' comment was posted to. Default is \code{FALSE}.
#' @param atRepliesOnly Logical. Comment \code{screen_names} must begin with an '@' symbol to be redirected.
#' Default is \code{TRUE}.
#' @param ... Additional parameters passed to function. Not used in this method.
#'
#' @return Network as a named list of two dataframes containing \code{$nodes} and \code{$edges}
#' including columns containing text data.
#'
#' @examples
#' \dontrun{
#' # add text to an actor network ignoring references to actors at the beginning of
#' # comment text
#' activityNetwork <- collectData |> Create("activity") |>
#'                                    AddText(collectData, repliesFromText = FALSE)
#'
#' # network
#' # activityNetwork$nodes
#' # activityNetwork$edges
#' }
#'
#' @aliases AddText.actor.youtube
#' @name AddText.actor.youtube
#' @export
AddText.actor.youtube <-
  function(net,
           data,
           repliesFromText = FALSE,
           atRepliesOnly = TRUE,
           ...) {
    # data <- tibble::as_tibble(data)
    class(data) <- rm_collect_cls(class(data))

    net$edges <- net$edges |> dplyr::left_join(
      dplyr::select(data, .data$CommentID, .data$Comment) |>
        dplyr::rename(
          comment_id = .data$CommentID,
          vosonTxt_comment = .data$Comment
        ),
      by = c("comment_id")
    )

    # in comment reply to's
    if (repliesFromText) {
      net$edges <- net$edges |> dplyr::left_join(dplyr::select(net$nodes,-.data$node_type),
                                      by = c("from" = "id"))
      vid_comments <-
        dplyr::select(net$edges, .data$video_id, .data$vosonTxt_comment) |> purrr::transpose()

      net$edges$at_id <- sapply(vid_comments, function(x) {
        for (name_at in net$nodes$screen_name) {
          if (atRepliesOnly) {
            name_at_regex <- paste0("^", escape_regex(paste0("@", name_at)))
          } else {
            name_at_regex <- paste0("^[@]?", escape_regex(name_at))
          }

          if (grepl(name_at_regex, x$vosonTxt_comment)) {
            to_id <-
              dplyr::filter(net$edges,
                            .data$screen_name == name_at & .data$video_id == x$video_id) |>
              dplyr::select(.data$from) |> dplyr::distinct()
            if (nrow(to_id)) {
              return(as.character(tail(to_id, n = 1)))
            } # choose last match - best effort
          }
        }
        return(as.character(NA))
      })
      net$edges <- net$edges |> dplyr::mutate(
        to = ifelse(is.na(.data$at_id), .data$to, .data$at_id),
        edge_type = ifelse(
          is.na(.data$at_id),
          .data$edge_type,
          "reply-comment-text"
        )
      )
      # , at_id = NULL # leave in for reference
    }

    class(net) <- union(class(net), c("vosontxt"))
    msg("Done.\n")

    net
  }

#' @title Add columns containing text data to reddit actor network dataframes
#'
#' @param net A named list of dataframes \code{nodes} and \code{edges} generated by \code{Create}.
#' @param data A dataframe generated by \code{Collect}.
#' @param cleanText Logical. Simple removal of problematic characters for XML 1.0 standard. Implemented to prevent
#' reddit specific XML control character errors when generating graphml files. Default is \code{FALSE}.
#' @param ... Additional parameters passed to function. Not used in this method.
#'
#' @return Network as a named list of two dataframes containing \code{$nodes} and \code{$edges}
#' including columns containing text data.
#'
#' @aliases AddText.actor.reddit
#' @name AddText.actor.reddit
#' @export
AddText.actor.reddit <-
  function(net, data, cleanText = FALSE, ...) {
    # data <- tibble::as_tibble(data)
    class(data) <- rm_collect_cls(class(data))

    # rename the edge attribute containing the thread comment
    net$edges <- dplyr::left_join(
      net$edges,
      dplyr::select(
        data,
        .data$subreddit,
        .data$thread_id,
        .data$id,
        .data$comment
      ),
      by = c("subreddit", "thread_id", "comment_id" = "id")
    ) |>
      dplyr::rename(vosonTxt_comment = .data$comment)

    authors <-
      dplyr::select(data,
                    .data$subreddit,
                    .data$thread_id,
                    .data$title,
                    .data$post_text) |>
      dplyr::distinct() |> dplyr::mutate(comment_id = 0)

    net$edges <-
      dplyr::left_join(net$edges,
                       authors,
                       by = c("subreddit", "thread_id", "comment_id")) |>
      dplyr::mutate(
        vosonTxt_comment = ifelse(
          .data$comment_id == 0,
          .data$post_text,
          .data$vosonTxt_comment
        ),
        post_text = NULL
      )

    net$edges$vosonTxt_comment <-
      ifelse(trimws(net$edges$vosonTxt_comment) == "",
             NA,
             net$edges$vosonTxt_comment)

    if (cleanText) {
      net$edges$vosonTxt_comment <-
        xml_clean_reddit(net$edges$vosonTxt_comment)
      net$edges$title <- xml_clean_reddit(net$edges$title)
    }

    class(net) <- union(class(net), c("vosontxt"))
    msg("Done.\n")

    net
  }

# extract text from nested tweet fields
extract_nested_tweet_text <- function(x, var, hashtags = FALSE) {
  df <- x |>
    dplyr::select({{ var }}) |>
    tidyr::unnest(cols = c({{ var }}))

  if (ncol(df) == 1) { return(NULL) }

  df <- df |>
    dplyr::filter(!is.na(.data$id_str)) |>
    dplyr::select(.data$id_str, .data$full_text, .data$entities) |>
    dplyr::distinct(.data$id_str, .keep_all = TRUE)

  if (hashtags) {
    df <- df |>
      dplyr::mutate(hashtags = .data$entities$hashtags) |>
      tidyr::hoist(
        .col = .data$hashtags,
        hashtags = list("text"),
        .remove = FALSE
      )

    df$hashtags[df$hashtags == "NULL"] <- NA_character_
  }

  df <- df |> dplyr::select(-.data$entities)

  df
}

# extract and add text to twitter network nodes or edges
add_tweet_text <- function(objs, data, hashtags = FALSE) {

  objs <-
    dplyr::left_join(
      objs,
      dplyr::select(
        data,
        .data$status_id,
        .data$is_reply,
        .data$is_quote,
        .data$is_retweet,
        .data$full_text,
        .data$entities
      ) |> dplyr::distinct(.data$status_id, .keep_all = TRUE),
      by = "status_id")

  if (hashtags) {
    objs <- objs |>
      tidyr::hoist(
        .col = .data$entities,
        hashtags = list("hashtags", "text"),
        .remove = FALSE
      )

    objs$hashtags[objs$hashtags == "NULL"] <- NA_character_
  }

  objs <- objs |>
    dplyr::select(-.data$entities) |>
    dplyr::mutate(
      full_text = ifelse(!is.na(.data$full_text), .data$full_text, NA_character_)
    )

  objs <- objs |> dplyr::mutate(vosonTxt_tweet = .data$full_text)

  # nested quote tweets
  qs <- extract_nested_tweet_text(data, "qs", hashtags)
  if (!is.null(qs)) {
    qs <- qs |> dplyr::rename_with(function(x) paste0("quoted_", x))
    objs <- objs |> dplyr::left_join(qs, by = c("status_id" = "quoted_id_str")) |>
      dplyr::mutate(vosonTxt_tweet = ifelse(is.na(.data$vosonTxt_tweet),
                                            .data$quoted_full_text, .data$vosonTxt_tweet))
  }

  # nested retweets
  rts <- extract_nested_tweet_text(data, "rts", hashtags)
  if (!is.null(rts)) {
    rts <- rts |> dplyr::rename_with(function(x) paste0("retweeted_", x))
    objs <- objs |> dplyr::left_join(rts, by = c("status_id" = "retweeted_id_str")) |>
      dplyr::mutate(vosonTxt_tweet = ifelse(is.na(.data$vosonTxt_tweet),
                                            .data$retweeted_full_text, .data$vosonTxt_tweet))
  }

  objs$vosonTxt_tweet <- textutils::HTMLdecode(objs$vosonTxt_tweet)

  objs <- objs |> dplyr::relocate(.data$vosonTxt_tweet, .after = dplyr::last_col())

  objs
}
